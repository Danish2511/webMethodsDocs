<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="true" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="shortcut icon" href="favicon.ico" type="image/x-icon" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>Communication Drivers</title><link rel="Prev" href="to-header_js_communication_methods.html" title="Previous" /><link rel="Next" href="co-websocket_6.html" title="Next" /><link rel="StyleSheet" href="css/_universal_messaging_docset_reverb_diba2.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><!--[if IE 7]><link rel="StyleSheet" href="css/_universal_messaging_docset_reverb_diba2_IE7.css" type="text/css" media="all" /><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if ((window === window.top) && (window.navigator.userAgent.indexOf('bot/') === -1)) {
        // Redirect
        //
        redirect_url = "../index.html#page/num-webhelp/co-drivers_6.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pwZtdmsTZCXnM6zShP6Z49g" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/num-webhelp/co-drivers_6.html');"><header id="wwconnect_header"><!-- Produkt Name und Version in Breadcrumbs SQ --><div class="ww_skin_breadcrumbs"><span>Universal Messaging</span>&nbsp;10.15 |
		     <span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-title_developer_guide.html#wwconnect_header">Developer Guide</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-header_web_client_apis.html#wwconnect_header">Web Client APIs</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-header_javascript.html#wwconnect_header">Web Developer's Guide for Javascript</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-header_js_communication_methods.html#wwconnect_header">JavaScript Communication Drivers and Protocols</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_current">Communication Drivers</span></div><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a></div></header><div id="wwID0E1JRW" class="Heading_4">Communication Drivers</div><div id="wwID0EJKRW" class="Section_Title">Overview</div><div id="wwID0EOKRW" class="Body">JavaScript communication drivers use streaming techniques or long polling, as required.</div><div id="wwID0ETKRW" class="Body">For a full list, please see the JavaScript API Documentation for Drivers.</div><div id="wwID0EYKRW" class="Body">The following links provide a basic description of the main techniques employed by these drivers:</div><div id="wwID0EDLRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>
    <a href="../num-webhelp/co-websocket_6.html#wwID0ELMTW"
   
     title="WebSocket Delivery Mode"
    ><span class="heading-page">HTML5 WebSocket</span></a></div><div id="wwID0E6LRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>
    <a href="../num-webhelp/co-cometstreaming_6.html#wwID0EEEUW"
   
     title="Comet Streaming Delivery Mode"
    ><span class="heading-page"> Comet Streaming</span></a></div><div id="wwID0E2MRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>
    <a href="../num-webhelp/co-longpoll_6.html#wwID0ECIUW"
   
     title="Comet LongPolling Delivery Mode"
    ><span class="heading-page">Comet LongPolling</span></a></div><div id="wwID0EAORW" class="Section_Title">Standard HTTP Polling</div><div id="wwID0EFORW" class="Body">Most non-Universal Messaging web applications make use of repeated, standard HTTP polling requests. Such application requests/responses look like this:</div><div class="ww_skin_page_overflow"><div id="wwID0EZNRW-4" class="Section"><img class="Default" src="../num-webhelp/images/standardhttp.png" width="100%" style="display: block; float: none; left: 0pt; max-height: 586px; max-width: 319px; top: 0pt" alt="" /></div></div><div id="wwID0ESORW" class="Body">The Universal Messaging JavaScript API is more efficient than this. It implements several underlying drivers for communication between a Universal Messaging JavaScript client and a Universal Messaging realm server. These drivers can be conceptually divided into:</div><div id="wwID0E4ORW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>streaming drivers</div><div id="wwID0EQPRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>long polling drivers</div><div id="wwID0EMQRW" class="Section_Title">Streaming Drivers</div><div id="wwID0ERQRW" class="Body">The Streaming drivers implemented in Universal Messaging take advantage of various technologies implemented in different web browsers, and various mechanisms to achieve HTTP server push or HTTP streaming. These technologies and mechanisms include HTML5 Web Sockets, chunked XMLHTTPRequest and XDomainRequest responses, EventSource/SSE, iFrame Comet Streaming and more.</div><div id="wwID0EWQRW" class="Body">The fundamental difference between Universal Messaging JavaScript API's Streaming drivers and standard HTTP polling is that the Universal Messaging realm server will not terminate the HTTP connection after it sends response data to the client. The connection will remain open so that if additional data (such as Universal Messaging events) becomes available for the client, it can immediately be delivered to the client without having to be queued and without having to wait for the client to make a subsequent request. The client can interpret the "partial" response chunks as they arrive from the server.</div><div class="ww_skin_page_overflow"><div id="wwID0EFQRW-6" class="Section"><img class="Default" src="../num-webhelp/images/streaming.png" width="100%" style="display: block; float: none; left: 0pt; max-height: 796px; max-width: 479px; top: 0pt" alt="" /></div></div><div id="wwID0EDRRW" class="Body">This is much more efficient than standard HTTP polling, since the client need only make a single HTTP request, yet receive ongoing data in a single, long lived response.</div><div id="wwID0EIRRW" class="Body">Streaming drivers are the preferred drivers to use in a Universal Messaging JavaScript application. Do note, however, that some environments may limit the successful use of streaming drivers (such as intermediate infrastructure with poorly configured client-side proxy servers or reverse proxy servers). In these instances, clients can be configured to fall back to a Long Polling driver (which can be considered a driver "of last resort").</div><div id="wwID0EVRRW" class="Section_Title">Long Polling Drivers</div><div id="wwID0E1RRW" class="Body">When using a Long Polling driver, a Universal Messaging client requests information from the realm server in a similar way to a normal HTTP poll. The primary difference is that if the server does not have any information for the client at that time, then instead of sending an empty response and closing the connection, the server will instead hold the request and wait for information (for example, Universal Messaging events) to become available. Once information is available for the client, the server completes its response and closes the connection. The Universal Messaging client will then immediately make a new Long Poll request for the next batch of information:</div><div class="ww_skin_page_overflow"><div id="wwID0EORRW-4" class="Section"><img class="Default" src="../num-webhelp/images/longpoll.png" width="100%" style="display: block; float: none; left: 0pt; max-height: 691px; max-width: 522px; top: 0pt" alt="" /></div></div><div id="wwID0EHSRW" class="Body">Clearly, if information is constantly being provided, then a client will end up making very frequent Long Poll requests (potentially as frequently as it would with a normal HTTP poll approach). The Universal Messaging realm server can be configured to delay responding and closing a connection for as long as desired (thereby allowing administrators the option of making requests be fulfilled as soon as data is available, or waiting for a time period, allowing information to accumulate further, before responding - this latter technique is recommended if a client is likely to receive many events per second).</div><div id="wwID0EMSRW" class="Body">Long Polling drivers are therefore not true "push" drivers, and should only be used under circumstances where real push is not possible (owing, for instance, to intermediate infrastructure such as poorly configured client-side proxy servers or reverse proxy servers).</div><div id="wwID0EZSRW" class="Section_Title">Infrastructural Issues and Workarounds</div><div id="wwID0E5SRW" class="Body">Universal Messaging JavaScript clients are intended to receive data in near real-time. To facilitate this, such clients will tend to use one of the API's Streaming drivers (as opposed to a basic, repetitive HTTP polling).</div><div id="wwID0EDTRW" class="Body">In most environments, a Streaming driver - which works over HTTP - can be used without problem. In some environments, however, infrastructure components can interfere with the real-time HTTP streams. Here we will look at some possible causes of interference, and discuss how to work around them.</div><div id="wwID0EQTRW" class="Section_Title">Client-Side Proxy Servers</div><div id="wwID0EVTRW" class="Body">Most client side proxy servers will permit a client to make a long lived connection to a Universal Messaging realm server (to see why a long-lived connection is important, please see the discussion of Streaming drivers above).</div><div id="wwID0E1TRW" class="Body">In some environments, however, a proxy server might interrupt these connections. This might be, for example, because:</div><div id="wwID0EFURW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>the proxy server wishes to "virus check" all content it receives on behalf of its clients. In this case the proxy server may buffer the streaming response in its entirety before "checking" it and delivering it to the client. Since the response is, essentially, unending, the proxy will never deliver any such content to the client and the client will be forced to reset and try again. If the client has been configured to try other drivers, it will eventually fall back to a long-polling driver (which should work perfectly well in such an environment).</div><div id="wwID0EYURW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>some companies may limit the size of responses which the proxy server will handle. In this case, the proxy server will forcefully close the connection. As a result, a Universal Messaging JavaScript client will automatically attempt to re-initialize the session, and gracefully continue. This should not affect usability too much (though clients will experience an unnecessary disconnect/reconnect cycle).</div><div id="wwID0ELVRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>some companies may limit the time for which a connection can remain open through the proxy. Again, a Universal Messaging JavaScript client will automatically work around this as above.</div><div id="wwID0E6VRW" class="Body">It is strongly recommended that you use SSL-encrypted HTTP for your Universal Messaging applications. Many proxy servers will allow SSL-encrypted HTTP traffic to pass unhindered. This will ensure that the greatest number of clients can use an efficient streaming driver.</div><div id="wwID0EMWRW" class="Section_Title">Reverse Proxy Servers and Load Balancers</div><div id="wwID0ERWRW" class="Body">If your infrastructure includes a reverse proxy server or a load balancer, it is important to ensure that "stickiness" is enabled if you are using this infrastructure to front more than one Universal Messaging realm server. That is, requests from an existing client should always be made to the same back end Universal Messaging realm server.</div><div id="wwID0EWWRW" class="Body">Most load balancers offer stickiness based either on client IP address or using HTTP cookies. Client IP based stickiness can work well (though be aware that some clients may be making requests from different IP addresses, if, for instance, they are behind a bank of standard proxy servers in their own environment). Cookie-based stickiness will work well for most drivers (though note that some drivers, notably the "XDR" drivers which are based on the XDomainRequest object from <span class="Keyword">Microsoft</span>, do not support cookies - please see the JavaScript API Documentation for Drivers for more information).</div><div id="wwID0EJXRW" class="Section_Title">Choosing Appropriate Drivers for Your Environment</div><div id="wwID0EOXRW" class="Body">While the default set of drivers work well in a simple environment where browsers connect directly to the server without intermediate infrastructure such as ill-configured proxy servers or overly-aggressive antivirus products, in some cases you may wish to customise the driver set to minimise issues with clients behind such infrastructure.</div><div id="wwID0ETXRW" class="Body">In summary, to minimise rare but lengthy delays where present-day client infrastructure interferes with session initialization, use the following set:</div><div id="wwID0E5XRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_STREAMING_CORS</div><div id="wwID0ERYRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_STREAMING</div><div id="wwID0EEZRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>IFRAME_STREAMING_POSTMESSAGE</div><div id="wwID0EXZRW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>EVENTSOURCE_STREAMING_POSTMESSAGE</div><div id="wwID0EK1RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_LONGPOLL</div><div id="wwID0E41RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_CORS</div><div id="wwID0EQ2RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_POSTMESSAGE</div><div id="wwID0ED3RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>JSONP_LONGPOLL</div><div id="wwID0EX3RW" class="Body">AND use HTTPS with SSL certificates for the servers on which you deploy your HTML/JS and for all the UM servers.</div><div id="wwID0EE4RW" class="Section_Title">More Details</div><div id="wwID0EJ4RW" class="Body">Unless configured otherwise, Universal Messaging JavaScript clients will attempt to use the following drivers, in decreasing order of preference:</div><div id="wwID0EU4RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>WEBSOCKET: Streaming driver for browsers supporting HTML5 Web Sockets.</div><div id="wwID0EH5RW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_STREAMING_CORS: Streaming driver for browsers supporting XMLHTTPRequest with CORS (Cross-Origin Resource Sharing). Intended for <span class="Keyword">Google</span> <span class="Keyword">Chrome</span>, <span class="Keyword">Mozilla</span> <span class="Keyword">Firefox</span>, <span class="Keyword">Apple</span> <span class="Keyword">Safari</span>, <span class="Keyword">Microsoft</span> <span class="Keyword">Internet Explorer</span> 10+.</div><div id="wwID0ECASW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_STREAMING: Streaming driver for browsers supporting XDomainRequest (Internet Explorer 8+). Intended for Internet Explorer 8 and Internet Explorer 9. Note that XDomainRequest and hence the XDR_STREAMING driver can not send client cookies to the server.</div><div id="wwID0EVASW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>IFRAME_STREAMING_POSTMESSAGE: Streaming driver for browsers supporting the cross-window postMessage API (per https://developer.mozilla.org/en/DOM/window.postMessage). Intended for Chrome, Firefox, Safari, Internet Explorer 8+ and Microsoft Edge.</div><div id="wwID0EIBSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>EVENTSOURCE_STREAMING_POSTMESSAGE: Streaming driver for browsers supporting both Server-Sent-Events and the cross-window postMessage API.</div><div id="wwID0E2BSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_LONGPOLL: Longpoll driver for browsers supporting XDomainRequest (Internet Explorer 8+). Intended for Internet Explorer 8 and Internet Explorer 9. Note that XDomainRequest and hence the XDR_STREAMING driver can not send client cookies to the server.</div><div id="wwID0EOCSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_CORS: Longpoll driver for browsers supporting XMLHTTPRequest with CORS (Cross-Origin Resource Sharing). Intended for Chrome, Firefox, Safari, Internet Explorer 10+ and Microsoft Edge.</div><div id="wwID0EBDSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_POSTMESSAGE: Longpoll driver for browsers supporting the cross-window postMessage API. Intended for Chrome, Firefox, Safari, Internet Explorer 8+ and Microsoft Edge.</div><div id="wwID0EUDSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>NOXD_IFRAME_STREAMING: Legacy non-cross domain streaming driver for older clients requiring streaming from the server that serves the application itself. Intended for Chrome, Firefox, Safari, Internet Explorer 6+ and Microsoft Edge.</div><div id="wwID0EHESW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>JSONP_LONGPOLL: Longpoll driver for older browsers relying on DOM manipulation only (no XHR or similar required). Intended for Chrome, Firefox, Safari, Internet Explorer 6+ and Microsoft Edge.</div><div id="wwID0E2ESW" class="Body">The vast majority of clients settle on one of the first three streaming drivers.</div><div id="wwID0EAFSW" class="Body">As outlined in the API documentation, the developer can override the driver set and preference order. This is rarely recommended, however, unless a significant proportion of clients are located behind infrastructure which interrupt communication based on the typically preferred drivers. We shall explain how such interruptions can manifest themselves for each of these driver types.</div><div id="wwID0EFFSW" class="Body">Firstly, a little more detail on how driver failover works for the JavaScript API.</div><div id="wwID0EKFSW" class="Body">We will first look at how a client communicates with a single UM server:</div><div id="wwID0EPFSW" class="Body">A client browser first checks whether it supports the underlying technologies on which the current driver is based. If it does not, then it removes the driver from its list of possible drivers and will never attempt to use it again.</div><div id="wwID0EUFSW" class="Body">If the browser successfully initializes a session with the server, then it will always try to use the same driver thereafter, and will NOT fail over to a different driver (unless the user reloads the application).</div><div id="wwID0EZFSW" class="Body">If a browser does support the driver, then the driver gets 3 consecutive attempts to initialize a session. The first attempt happens immediately. The second connection attempt has a delay of 1 second. The third attempt has a delay of 2 seconds. This is to avoid compounding problems on a server that may be undergoing maintenance or other load issues (this is of particular importance if an environment supports many users, or has been configured to use only a single realm server).</div><div id="wwID0E5FSW" class="Body">After the third failure, if the client's session object has been configured with more than one driver (or if it is using the default set), then it will switch to the next driver, and will once again immediately try to connect and initialize a session. Such drivers' second and third attempts are subject to the same introduced delays as described above.</div><div id="wwID0EDGSW" class="Body">Next, let us look at how a client communicates with a cluster of UM servers:</div><div id="wwID0EIGSW" class="Body">When attempting to initialize a session with a server within a cluster, then a client will go through all drivers until one works, as described above. A side effect of this is that if the first server with which the client attempts to communicate is unresponsive, then one can expect a delay of at least (number_of_supported_drivers * 3 seconds) plus any underlying request timeouts before the client switches to the next UM server. In a worst-case scenario this could lead to a delay of 20 seconds or more, which is far from desirable.</div><div id="wwID0ENGSW" class="Body">This delay would be this considerable only when the first UM server the client attempted to use was unavailable. Had the first UM server been available, and subsequently become unavailable (thus disconnecting the browser), the browser will switch to a second realm server considerably more quickly, because:</div><div id="wwID0EYGSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>If the browser gets a confirmed session to server X, then - as explained earlier - it will always try to use that driver thereafter.</div><div id="wwID0ELHSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>If, having had a confirmed session to server X it gets disconnected from server X, then it will continue retrying to connect to server X with the same driver for a maximum of 5 consecutive failed attempts (any successful connection will reset the failure count to 0). If the 5th attempt fails, the browser will consider this server to be unavailable, and will switch to the next server, re-enable *all* drivers, and start cycling through them again (giving each one 3 chances to connect as usual). On the assumption that the second realm server is indeed available, a client would, at this point, reconnect immediately.</div><div id="wwID0E6HSW" class="Body">So one key here is to avoid including realms servers in a client's session configuration object if they are known to be not available pre-session-initialization. This can be done by dynamically generating session configuration objects based upon the availability of back-end servers (though this is beyond the scope of the UM API).</div><div id="wwID0EEISW" class="Body">An alternative approach to avoid such a delay would be to lower the number of potential drivers a browser could attempt - but this will doubtlessly lead to fewer clients being able to connect, so is not recommended.</div><div id="wwID0EJISW" class="Body">Finally, let's look at the individual drivers themselves. All notes below are for traffic over HTTP (not HTTPS):</div><div id="wwID0EHJSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>WEBSOCKET Streaming driver for browsers supporting HTML5 Web Sockets.</div><div id="wwID0EZJSW" class="List_1_Continued">In a typical production deployment, one would expect the majority of external client browsers to not be able to communicate using WebSockets. There are several reasons for this:</div><div id="wwID0EEKSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>Firstly, a significant proportion of end users are using web browsers that do not yet support the WebSocket protocol (e.g. around 30% of users are on Internet Explorer 9 or earlier, with no WebSocket support).</div><div id="wwID0EXKSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>Secondly, users behind corporate proxy servers will, at present, find that the proxy server will in all likelihood not support the WebSocket protocol, even if their browser does; this is expected to change, but it will take years, not months.</div><div id="wwID0EKLSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>Thirdly, many companies wish to deploy their UM servers behind standard reverse proxy servers or load balancers; again, WebSocket support will appear in such products, but it is simply not there today.</div><div id="wwID0E4LSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>Fourthly, a client-side antivirus product can interfere with the browser's receipt of real-time data sent down a WebSocket response. This is common, for example, for clients using Avast's WebShield functionality - these clients usually have to be configured to use a long polling driver unless they configure their antivirus product to ignore traffic from specific hosts. The issue is that the antivirus product attempts to buffer the entire response so that it can process it for viruses and the like before giving it to the client. Avast upgraded their product to better handle WebSocket last year, and as part of that process they have whitelisted a number of well-known sites that use WebSocket, but may be still being a little overzealous with WebSocket connections to hosts they don't know.</div><div id="wwID0ERMSW" class="List_1_Continued">These issues in combination make it more likely than not that a corporate web user will be unable to use WebSockets.</div><div id="wwID0EWMSW" class="List_1_Continued">That said, if a browser doesn't support WebSocket, it will fail over to the next driver immediately. On the other hand, if the browser does support WebSockets, but an intermediate proxy or reverse proxy server doesn't, then the WebSocket HTTP handshake would, in some circumstances, result in the proxy immediately returning an error response to the browser. Under these conditions, the browser will retry the WebSocket driver a maximum of three times (incurring the "3 second" delay as per the "back-off" rules described above) before failing over to the next driver. The worse case scenario is a client using a proxy that simply ignores the WebSocket HTTP Protocol Upgrade handshake; here you are at the mercy of the client timing out, as the UM server would never receive the WebSocket upgrade request. Although you can set these timeouts to whatever values you wish, the default values are set to support clients on slow connections - lowering them will cause clients on slow connections to frequently fail to initialize sessions.</div><div id="wwID0E2MSW" class="List_1_Continued">For client environments that support it, WebSocket is an excellent choice of driver. Whether you wish to risk a 3-second delay (or, in the rare cases described above, much higher) for those client environments that don't support it is down to your distribution of customers. If you are building applications targeting customers whose infrastructure you understand, then it is worth using the WebSocket driver. If the audience is more generally distributed, then a good proportion of the clients that are unable to use WebSockets will incur a session initialization delay. You may therefore wish to exclude the WEBSOCKET driver from your application's session configuration.</div><div id="wwID0EUNSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_STREAMING_CORS Streaming driver for browsers supporting XMLHTTPRequest with CORS (Cross-Origin Resource Sharing). Intended for Chrome, Firefox, Safari, Internet Explorer 10+.</div><div id="wwID0EGOSW" class="List_1_Continued">Unlike WebSocket, this driver does not rely on anything other than standard HTTP requests and a streaming HTTP response. If the client supports the driver, the only issues here are intermediate infrastructure components interfering with the real-time stream of data sent from the UM server to the client:</div><div id="wwID0EROSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>An intermediate proxy server may choose to buffer the streamed response rather than streaming it directly to the client in real-time. Some have a habit of buffering all un-encrypted traffic for virus-scanning purposes, thus preventing clients from using streaming drivers of any kind. This is not very common, but it does happen.</div><div id="wwID0EEPSW" class="List_2"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>More common is the interruption of a streamed response by client-side antivirus products like Avast's WebShield (see above, in the WebSocket driver discussion). In these cases, the browser would not receive the session initialization response (as it is being buffered by the antivirus product), and would eventually time out. This is much slower than failing immediately.</div><div id="wwID0EMQSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_STREAMING Streaming driver for browsers supporting XDomainRequest (Internet Explorer 8+). Intended for Internet Explorer 8 and Internet Explorer 9. Note that XDomainRequest and hence the XDR_STREAMING driver can not send client cookies to the server.</div><div id="wwID0E5QSW" class="List_1_Continued">Although Internet Explorer 8 and Internet Explorer 9 support the XHR object, they cannot use the XHR object to make cross-domain requests. This driver therefore instead uses a Microsoft-specific object called the XDomainRequest object which can support streaming responses to fully cross-domain requests.</div><div id="wwID0EDRSW" class="List_1_Continued">As mentioned in its description, this driver can not send client cookies to the server. This is because Microsoft chose to prevent cookies being sent via the XDR object. As a result, any intermediate DMZ infrastructure (such as a load balancer) that relies on client-side HTTP cookies to maintain, for example, load balancer server "stickiness", will be unable to maintain stickiness (since no cookies that the load balancer might set will appear in subsequent client requests when using an XDR based driver). If the load-balancer is fronting more than one UM server, then this setup can result in load balancers sending a client's post-session-initialization requests, such as a subscription request, to a random back-end UM server rather than to the server with which a client had initialized a (load-balancer-proxied) session. This will cause a client to reinitialize their session, and repeat ad infinitum. In these cases, if load balancers are indeed using cookie-based stickiness, then you have two options: either explicitly configure JavaScript sessions with a set of drivers that exclude all XDR variants, or change the load balancer configuration to use client IP-based stickiness instead of cookie-based stickiness instead</div><div id="wwID0E3RSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>IFRAME_STREAMING_POSTMESSAGE Streaming driver for browsers supporting the cross-window postMessage API (per https://developer.mozilla.org/en/DOM/window.postMessage). Intended for Chrome, Firefox, Safari, Internet Explorer 8+ and Microsoft Edge.</div><div id="wwID0EOSSW" class="List_1_Continued">In all likelihood, a client browser will settle on one of the three drivers discussed above before it would fail over to this driver. This driver is really only of use in environments where, for some reason, a browser is unable to create an instance of an XHR object. This used to be the the case in some older versions of Internet Explorer if, for example, a <span class="Keyword">Windows</span> Administrator's policy prevented Internet Explorer from being able to invoke ActiveX objects (such as the XMLHTTPRequest object). In modern versions of Internet Explorer, however, XMLHTTPRequest is a native non-ActiveX object so this is less of an issue.</div><div id="wwID0EZSSW" class="List_1_Continued">The downsides of this driver are the same as those for the XHR_STREAMING_CORS driver: proxy and antivirus product interference.</div><div id="wwID0ESTSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>EVENTSOURCE_STREAMING_POSTMESSAGE Streaming driver for browsers supporting both Server-Sent-Events and the cross-window postMessage API.</div><div id="wwID0EEUSW" class="List_1_Continued">This driver is really only useful to a small subset of modern browsers such as Opera. It does not rely on any unusual HTTP behaviour, and is therefore only subject to the same negatives as the other streaming drivers: proxy and antivirus product interference.</div><div id="wwID0E4USW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_LONGPOLL Longpoll driver for browsers supporting XDomainRequest (Internet Explorer 8+). Intended for Internet Explorer 8 and Internet Explorer 9. Note that XDomainRequest and hence the XDR_STREAMING driver can not send client cookies to the server.</div><div id="wwID0EPVSW" class="List_1_Continued">This is the most efficient long-polling driver for Internet Explorer 8 and Internet Explorer 9. Its downside is the lack of cookie support. This is only an issue if dealing with certain load balancer configurations (see discussion of XDR_STREAMING).</div><div id="wwID0EIWSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_CORS Longpoll driver for browsers supporting XMLHTTPRequest with CORS (Cross-Origin Resource Sharing). Intended for Chrome, Firefox, Safari, Internet Explorer 10+ and Microsoft Edge.</div><div id="wwID0E1WSW" class="List_1_Continued">This is the most efficient long-polling driver for non-Internet Explorer browsers and for Internet Explorer 10+.</div><div id="wwID0E6WSW" class="List_1_Continued">As with all long polling drivers (including XHR_LONGPOLL_POSTMESSAGE and JSONP_LONGPOLL discussed below), the browser will maintain an open connection to the server until data is available for transport to the browser. As soon as data arrives for delivery to the browser, the server will wait for a short period of time (known as the server-side "Long Poll Active Delay" timeout, which defaults to 100ms) before sending the data to the browser, and closing the connection. The browser will then immediately make a new long-poll connection to the server, in preparation for more data. Since the server closes the connection immediately after sending any data, any intermediary proxy servers or antivirus products will not be buffering the response in the same was as they might buffer a streaming response, but will instead immediately relay the response to the browser.</div><div id="wwID0EEXSW" class="List_1_Continued">Note that if no data is available to be sent to the browser (if, say, the client is subscribed to a channel which rarely contains events) then the long-poll connection will remain open for a limited period before being closed by the server (at which point the browser will automatically create a new long-poll request and wait for data once again). The length of time for which such "quiet" connections stay open is defined by the "Long Poll Idle Delay" value, which can be set using Enterprise Manager (see the JavaScript tab for the relevant Interface). It is important that this value is lower than the value of any intermediary proxy servers' own timeouts (which are often 60 seconds, but sometimes as low as 30 seconds). A suitable production value for "Long Poll Idle Delay" might therefore be 25000ms (25 seconds).</div><div id="wwID0EJXSW" class="List_1_Continued">This driver, like all long polling drivers, is good for browsers that want low-latency but infrequent updates. Long polling drivers are not a good choice for browsers that receive a continual stream of many messages per second, however (as the browser may end up making several requests per second to the server, depending upon the "Long Poll Active Delay" value). In such cases it would be prudent to increase the "Long Poll Active Delay" value significantly from its default value of 100ms, to perhaps 1000ms or more (while acknowledging that the browsers using a long polling driver in such a scenario would no longer be receiving "near-real-time" data). For browsers that are instead subscribed to channels that have relatively infrequent updates, the "Long Poll Active Delay" can potentially be lowered to 0, resulting in real-time delivery despite the use of a long-polling driver.</div><div id="wwID0ECYSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_POSTMESSAGE Longpoll driver for browsers supporting the cross-window postMessage API. Intended for Chrome, Firefox, Safari, Internet Explorer 8+ and Microsoft Edge.</div><div id="wwID0EUYSW" class="List_1_Continued">This is the most efficient long-polling driver for non-Internet Explorer browsers that do not support CORS, and is a cookie-supporting alternative to XDR_LONGPOLL for Internet Explorer 8 and Internet Explorer 9. See the XHR_LONGPOLL_CORS discussion for details on how long polling functions.</div><div id="wwID0ENZSW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>NOXD_IFRAME_STREAMING Legacy non-cross domain streaming driver for older clients requiring streaming from the realm that serves the application itself. Intended for Chrome, Firefox, Safari, Internet Explorer 6+ and Microsoft Edge.</div><div id="wwID0E6ZSW" class="List_1_Continued">This is a streaming driver that is subject to the same issues as the other streaming drivers: proxy and antivirus product interference.</div><div id="wwID0EE1SW" class="List_1_Continued">In addition, unlike all the other drivers, which are fully cross-domain (allowing communication to a UM server on a different domain to the server that serves the applications HTML/JS), this driver only permits communication back to the same server that served the HTML/JS. This implies that the application's HTML/JS must be served from a file plugin on the UM server in question.</div><div id="wwID0E41SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>JSONP_LONGPOLL Longpoll driver for older browsers relying on DOM manipulation only. Browser will show "busy indicator/throbber" when in use. Intended for Chrome, Firefox, Safari, Internet Explorer 6+ and Microsoft Edge.</div><div id="wwID0EP2SW" class="List_1_Continued">This is the least efficient long-poll driver, but the most likely one to work in all circumstances. See the XHR_LONGPOLL_CORS discussion for details on how long polling functions.</div><div id="wwID0E52SW" class="Section_Title">Dealing with Intermediate Infrastructure Issues</div><div id="wwID0ED3SW" class="Body">As you can see, proxy servers are a particular bane for streaming HTTP traffic. Happily, practically all of these issues can be mitigated simply by using HTTPS instead of HTTP. In these cases, a proxy server will blindly proxy the HTTPS traffic without attempting to understand or modify the HTTP conversation contained within, and without interfering with it. If, therefore, you deploy your application on an HTTPS server, and install SSL certificates on your UM servers, you should be able to use the default set of drivers with minimal problems.</div><div id="wwID0EI3SW" class="Body">We would also point out that in our experience all production deployments at our customers' sites are secured with HTTPS (SSL or TLS). Besides helping browsers behind certain proxy servers maintain persistent connections that would otherwise be interrupted by naively configured proxy servers (perhaps buffering for virus checking), or by misconfigured or old proxies (that cannot understand WebSocket Protocol Upgrade handshakes), HTTPS offers clear security benefits and improves usability.</div><div id="wwID0EN3SW" class="Body">Working around client-side antivirus products is a little more difficult, unfortunately. One option might be to offer a link to a "long-poll-only" version of the application, and to show this link on screen only when a client is attempting to initialize a session for the first time. For clients which successfully initialize a session using a streaming driver, the link will be replaced with actual application content in no time, but for clients having problems, the ability to click a "click here if you're having problems connecting" is probably sufficient.</div><div id="wwID0ES3SW" class="Body">Other "workarounds", such as remembering the driver that worked for a browser as a value within a persistent cookie (so that it can be reused automatically thereafter), are risky; a client can be a laptop which subsequently connects via a proxy with a completely different configuration, for example. Such approaches are best not relied upon.</div><div id="wwID0EX3SW" class="Body">It is a shame to abandon WebSocket given its clear benefits, but in a production deployment we would, for the sake of simplicity, suggest the following as a useful custom set of drivers:</div><div id="wwID0EC4SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_STREAMING_CORS</div><div id="wwID0EV4SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_STREAMING</div><div id="wwID0EI5SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>IFRAME_STREAMING_POSTMESSAGE</div><div id="wwID0E25SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>EVENTSOURCE_STREAMING_POSTMESSAGE</div><div id="wwID0EO6SW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XDR_LONGPOLL</div><div id="wwID0EBATW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_CORS</div><div id="wwID0EUATW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_POSTMESSAGE</div><div id="wwID0EHBTW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>JSONP_LONGPOLL</div><div id="wwID0E2BTW" class="Body">This basically leaves out WEBSOCKET because of the risk of a prolonged "failure" time for a minority of clients behind incompatible proxies, and also leaves out the "legacy" NOXD_IFRAME_STREAMING driver since this is the only non-cross-domain driver, and it is likely that any production application's HTML/JS would benefit from being deployed on a static WebServer rather than on a file plugin within the messaging server.</div><div id="wwID0EACTW" class="Body">If your DMZ infrastructure includes load balancer components that rely on HTTP cookies for "stickiness", then the XDR-based drivers should not be used (see the discussion of XDR_STREAMING above). In this case, the set of custom drivers would be best reduced to:</div><div id="wwID0ELCTW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_STREAMING_CORS</div><div id="wwID0E5CTW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>IFRAME_STREAMING_POSTMESSAGE</div><div id="wwID0ERDTW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>EVENTSOURCE_STREAMING_POSTMESSAGE</div><div id="wwID0EEETW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_CORS</div><div id="wwID0EXETW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>XHR_LONGPOLL_POSTMESSAGE</div><div id="wwID0EKFTW" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>JSONP_LONGPOLL</div><div id="wwID0EGGTW" class="Section_Title">What Drivers Should I Use?</div><div id="wwID0ELGTW" class="Body">This example can help you choose a suitable configuration:</div><div class="ww_skin_page_overflow"><table class="Default" cellspacing="0" summary=""><tr><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top; width: 50%"><div id="wwID0ELHTW" class="Table_Cell">Are your application's clients typically behind proxy servers?</div></td><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top; width: 50%"><div id="wwID0ERHTW" class="Table_Cell">Yes</div></td></tr><tr><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0E2HTW" class="Table_Cell">Is your Universal Messaging server behind a Load Balancer?</div></td><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0EBITW" class="Table_Cell">No, we do not use a Load Balancer</div></td></tr><tr><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0ELITW" class="Table_Cell">Is your Universal Messaging server behind a Reverse Proxy Server?</div></td><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0ERITW" class="Table_Cell">No, we do not use a Reverse Proxy Server</div></td></tr><tr><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0E2ITW" class="Table_Cell">Where is your application's HTML/JS served from?</div></td><td class="Table_Cell" style="border-bottom-color: Black; border-bottom-style: solid; border-bottom-width: 1px; border-left-color: Black; border-left-style: solid; border-left-width: 1px; border-right-color: Black; border-right-style: solid; border-right-width: 1px; border-top-color: Black; border-top-style: solid; border-top-width: 1px; padding-left: 2pt; padding-right: 2pt; vertical-align: top"><div id="wwID0EBJTW" class="Table_Cell">It is served from a different web server (e.g. Apache)</div></td></tr></table></div><div id="wwID0ELJTW" class="Body">Suggested Session Driver Configuration:</div><div id="wwID0EQJTW" class="Preformatted">var session = Nirvana.createSession({<br /><br />    // The WEBSOCKET driver is best not used if clients are behind <br />    // traditional proxy servers.<br />    // NOXD_IFRAME_STREAMING excluded as it won't work when <br />    // hosting application HTML on a 3rd-party webserver.<br /><br />    drivers : [<br />        Nirvana.Driver.XHR_STREAMING_CORS,<br />        Nirvana.Driver.XDR_STREAMING,<br />        Nirvana.Driver.IFRAME_STREAMING_POSTMESSAGE,<br />        Nirvana.Driver.EVENTSOURCE_STREAMING_POSTMESSAGE,<br />        Nirvana.Driver.XDR_LONGPOLL,<br />        Nirvana.Driver.XHR_LONGPOLL_CORS,<br />        Nirvana.Driver.XHR_LONGPOLL_POSTMESSAGE,<br />        Nirvana.Driver.JSONP_LONGPOLL<br />    ]<br />});<br /></div><div id="wwID0EWJTW" class="Body">Corresponding Server-Side Configuration:</div><div id="wwID0E2JTW" class="Body">Remember to include the hostname(s) of all servers hosting your application HTML in the CORS Allowed Origins field.</div><div id="wwID0EAKTW" class="Body">Ensure that you have configured a file plugin on the Universal Messaging interface to which JavaScript clients will connect, and that you have configured it to serve /lib/js/crossDomainProxy.html correctly.</div><div id="wwID0EFKTW" class="Body">Ensure that the Long Poll Idle Delay value is set to be lower than your Load Balancer or Reverse Proxy server's timeout value. This setting is in ms, and a good value is usually around 25000.</div><div id="wwID0EKKTW" class="Body">Ensure that the Long Poll Idle Delay value is set to be lower than any intermediate proxy server's timeout value. Many proxy servers have timeouts as low as 30 seconds (though an administrator may have lowered this, of course). In the Universal Messaging server, this setting is in ms, and a pragmatic value is usually around 25000. You may need to lower it further if external clients behind remote proxy servers fail to maintain sessions when using a longpolling driver.</div><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><!-- SQ insert Footer --><br /><hr style="border:1px solid; border-color: #1776BF; " /><!-- FRWE: Why is the font family information hard-coded?? --><div style="font-family: 'Roboto', Sans-Serif; font-size: 10px; margin-top: 6px; margin-bottom: 6px; text-align: center;"><a href="http://www.softwareag.com/licenses">Copyright © 2013-2022&nbsp;Software AG, Darmstadt, Germany and/or Software AG USA, Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors</a></div><!-- SQ insert Date 
	 <div style="text-align: center; font-weight: bold;" wwpage:content="pub-date">January 1, 2015</div> --><!-- old Footer 2016
	  <div class="footer">Copyright &#169; <span wwpage:content="sag:product-copyrfirst"></span>, <span wwpage:content="sag:organization-copyrholder"></span>, <a href="http://sag.com/" wwpage:attribute-href="sag:organization-url" wwpage:content="sag:organization-url">http://sag.com/</a>
   --><!-- SQ Variablen --><!-- Copyright Test --><!--	  <div style="text-decoration: underline">Copyright Import Test:</div>
	  <wwpage:Import wwpage:content-from-file="Copyright/copyright_en.asp" />
	  <br></br>--><!--
	  <!-\- SQ Variables - Information from xresources -\->
	  <div style="text-decoration: underline">From xresources:</div>
	  <div>sag:organization-id == <span wwpage:content="sag:organization-id"></span></div>
	  <div>sag:organization-name == <span wwpage:content="sag:organization-name"></span></div>
	  <div>sag:organization-copyrholder == <span wwpage:content="sag:organization-copyrholder"></span></div>
	  <div>sag:organization-url == <span wwpage:content="sag:organization-url"></span></div>
	  
	  <div>sag:family-id == <span wwpage:content="sag:family-id"></span></div>
	  <div>sag:family-name == <span wwpage:content="sag:family-name"></span></div>
	  <div>sag:family-organization == <span wwpage:content="sag:family-organization"></span></div>
	  
	  <div>sag:product-id == <span wwpage:content="sag:product-id"></span></div>
	  <div>sag:product-name == <span wwpage:content="sag:product-name"></span></div>
	  <div>sag:product-copyrfirst == <span wwpage:content="sag:product-copyrfirst"></span></div>
	  <div>sag:product-family == <span wwpage:content="sag:product-family"></span></div>
	  
	  <!-\- SQ Variables - Values from DITA-Map and Keymap-\->
	  <br></br>
	  <div style="text-decoration: underline">From DITA/Book-Map:</div>
	  <div>ProdInfo Prodname == <span wwpage:replace="wwvars:ProdInfoProdName"></span></div>
	  <div>ProdInfo Mod First == <span wwpage:replace="wwvars:ProdInfoModFirst"></span></div>
	  <div>ProdInfo Mod Last == <span wwpage:replace="wwvars:ProdInfoModLast"></span></div>
	  <div>ProdInfo Rel First == <span wwpage:replace="wwvars:ProdInfoRelFirst"></span></div>
	  <div>ProdInfo Rel Last == <span wwpage:replace="wwvars:ProdInfoRelLast"></span></div>
	  <div>ProdInfo Vers First == <span wwpage:replace="wwvars:ProdInfoVersFirst"></span></div>
	  <div>ProdInfo Vers Last == <span wwpage:replace="wwvars:ProdInfoVersLast"></span></div>
	  <div>ProdInfo vrm vers.rel.mod == <span wwpage:replace="wwvars:ProdInfoVersFirst"></span>.<span wwpage:replace="wwvars:ProdInfoRelLast"></span>.<span wwpage:replace="wwvars:ProdInfoModLast"></span></div>
	  <div>BookID PartNo == <span wwpage:replace="wwvars:BookPartNo"></span></div>
	  <div>othermeta release-version == <span wwpage:replace="wwvars:ReleaseVersion"></span></div>
	  <div>othermeta release-date == <span wwpage:replace="wwvars:ReleaseDate"></span></div>
	  <div>othermeta release-edition == <span wwpage:replace="wwvars:ReleaseEdition"></span></div>
	  <div>othermeta product == <span wwpage:replace="wwvars:Product"></span></div>
	  <br></br>
	  <div style="text-decoration: underline">From x_runtime/keymap.ditamap:</div>
	  <div>sag:product-shortname == <span wwpage:replace="wwvars:sag:product-shortname"></span></div>
	  <div>sag:product-longname == <span wwpage:replace="wwvars:sag:product-longname"></span></div>
	  <div>versionAdd == <span wwpage:replace="wwvars:versionAdd"></span></div>
	  <div>yearFYLY == <span wwpage:replace="wwvars:yearFYLY"></span></div>
	  <div>fingerprint == <span wwpage:replace="wwvars:fingerprint"></span></div>
	  <div>sag:CopyrightDeclaration == <span wwpage:replace="wwvars:sag:CopyrightDeclaration"></span></div>
	  <div>pdfReleaseDate == <span wwpage:replace="wwvars:pdfReleaseDate"></span></div>
	  <div>documentID == <span wwpage:replace="wwvars:documentID"></span></div>
	  <br></br>
	  <div style="text-decoration: underline">Reserve:</div>
	  <div>organization == <span wwpage:content="organization"></span></div>
	  <div>product-name == <span wwpage:content="product-name"></span></div>
	  <div>copyright-first == <span wwpage:content="copyright-first"></span></div>
	  <div>copyright-last == <span wwpage:content="copyright-last"></span></div>
	  <div>copyright-first-b == <span wwpage:content="wwvars:copyright-first-b"></span></div>
	  <div>copyright-last-b == <span wwpage:content="copyright-last-b"></span></div>
	  <div>doc-id-one == <span wwpage:content="doc-id-one"></span></div>
	  <div>doc-id-two == <span wwpage:content="doc-id-two"></span></div>  
	  <div>Published == <span wwpage:content="pub-date"></span></div>
	  --></footer></body></html>