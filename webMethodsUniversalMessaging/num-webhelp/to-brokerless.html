<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="true" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="shortcut icon" href="favicon.ico" type="image/x-icon" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>umTransport API</title><link rel="Prev" href="to-zones_4.html" title="Previous" /><link rel="Next" href="to-communicationprotocols.html" title="Next" /><link rel="StyleSheet" href="css/_universal_messaging_docset_reverb_diba2.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><!--[if IE 7]><link rel="StyleSheet" href="css/_universal_messaging_docset_reverb_diba2_IE7.css" type="text/css" media="all" /><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if ((window === window.top) && (window.navigator.userAgent.indexOf('bot/') === -1)) {
        // Redirect
        //
        redirect_url = "../index.html#page/num-webhelp/to-brokerless.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pN6iHPhPqQsff9af2RoF2evQ" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/num-webhelp/to-brokerless.html');"><header id="wwconnect_header"><!-- Produkt Name und Version in Breadcrumbs SQ --><div class="ww_skin_breadcrumbs"><span>Universal Messaging</span>&nbsp;10.15 |
		     <span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-title_concepts.html#wwconnect_header">Concepts</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_parent"><a href="../num-webhelp/to-header_architecture.html#wwconnect_header">Architecture</a></span><span class="ww_skin_breadcrumbs_divider"> | </span><span class="ww_skin_breadcrumbs_current">umTransport API</span></div><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a></div></header><div id="wwID0EFPPM" class="Heading_2">umTransport API</div><div id="wwID0ENPPM" class="Body">Universal Messaging offers, in addition to its standard full-featured client-server API, an extremely lightweight client-client communication API known as the umTransport API.</div><div id="wwID0EZPPM" class="Section_Title">Broker-based Model</div><div id="wwID0E5PPM" class="Body">Historically, messaging architecture has predominantly been based on a 'broker in the middle' approach. This is often referred to as 'hub and spoke'. The broker acts as the communications hub, routing messages between logically decoupled peers:</div><div class="ww_skin_page_overflow"><div id="wwID0ESPPM-4" class="Section"><img class="Default" src="../num-webhelp/images/brokerbasedmodel.png" width="100%" style="display: inline; float: none; left: 0pt; max-height: 237px; max-width: 364px; top: 0pt" alt="" /></div></div><div id="wwID0ELQPM" class="Body">The pub-sub model is a common paradigm for broker based architecture, where one or more publishers send messages to the broker, which then distributes the messages to interested consumers.</div><div id="wwID0EYQPM" class="Section_Title">umTransport Model</div><div id="wwID0E4QPM" class="Body">The umTransport model is a peer to peer model that allows peers to be aware of how to communicate directly with one another rather than through a broker. In effect, each publisher peer acts like a server, and each consumer can communicate directly with the publishers:</div><div class="ww_skin_page_overflow"><div id="wwID0ERQPM-4" class="Section"><img class="Default" src="../num-webhelp/images/um_transport_model.png" width="100%" style="display: inline; float: none; left: 0pt; max-height: 246px; max-width: 337px; top: 0pt" alt="" /></div></div><div id="wwID0EKRPM" class="Body">While this model bypasses broker messaging functionality such as persistence or transactional semantics, it results in a considerably lower latency delivery of information from a publisher to a consumer. By halving of the number of "hops" between client and publisher, latency too is effectively halved. This is especially useful when ultra-low latency message delivery is paramount (in, for example, the links between pricing, quant and risk engines in FX trading platforms).</div><div id="wwID0EPRPM" class="Body">The umTransport API is currently available for Java and C++. For Java, it is located in the <span class="apiname">com.softwareag.um.modules.transport</span> package. For C++, it is located in <span class="apiname">com::softwareag::umtransport</span>.</div><div id="wwID0E5RPM" class="Section_Division">The Java API</div><div id="wwID0EDSPM" class="Body">The Java API is very simple, allowing each client to accept connections from other clients, and to receive arbitrary binary data from these clients synchronously or asynchronously. In many ways the API is similar to a standard TCP socket API, but offers the additional benefit of being able to use not just TCP sockets as a communication transport, but any of the following Universal Messaging communication technologies:</div><div id="wwID0EOSPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>TCP Sockets: data is transmitted directly over TCP Sockets</div><div id="wwID0EBTPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>SSL: data is SSL encrypted then transmitted over TCP Sockets</div><div id="wwID0EUTPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>SHM: data is transmitted via Shared Memory (for near-instant access by processes on the same machine)</div><div id="wwID0EHUPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>RDMA: data is transmitted via Remote Direct Memory Access (for access by processes on a remote machine; requires network adapters that support RDMA)</div><div id="wwID0E1UPM" class="Section_Division">The C++ API</div><div id="wwID0E6UPM" class="Body">The C++ API provides a subset of the functionality available in the Java API, with the following restrictions:</div><div id="wwID0EKVPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>The C++ API does not support asynchronous communication between clients.</div><div id="wwID0E4VPM" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="chapterTOC_bullet.png" alt="*" border="0" width="10" height="10" /></span></span>The C++ API does not support RDMA as a communication transport.</div><div id="wwID0EZWPM" class="Section_Title">Using the Java API</div><div id="wwID0E5WPM" class="Body">Let's take a quick look at how to use this API. Here is an example "echo" Java client and server; the EchoClient will write a string to the EchoServer; the EchoServer will respond to the EchoClient.</div><div id="wwID0EDXPM" class="Body">Here's the Java EchoClient:</div><div id="wwID0EIXPM" class="Preformatted">package com.softwareag.um.modules.examples.transport.echo;<br /><br />import com.softwareag.um.modules.transport.ClientContextBuilderFactory;<br />import com.softwareag.um.modules.transport.ClientTransportContext;<br />import com.softwareag.um.modules.transport.SynchronousTransport;<br />import com.softwareag.um.modules.transport.TransportFactory;<br />import com.softwareag.um.modules.examples.transport.SimpleMessage;<br />import com.softwareag.um.modules.examples.transport.SynchronousClient;<br /><br />import java.io.BufferedReader;<br />import java.io.IOException;<br />import java.io.InputStreamReader;<br /><br />/**<br /> * This sample app simply writes a string entered into the console to an EchoServer<br /> * The EchoServer will respond and this response will be output on the console.<br /> */<br />public class EchoClient {<br /><br />  public EchoClient(String url) throws IOException {<br />    //Use the factory to generate the required builder based on the protocol <br />    //in the url string<br />    ClientTransportContext context = ClientContextBuilderFactory.getBuilder(url).build();<br /><br />    //We do not pass any handlers to the connect method <br />    //because we want a synchronous transport<br />    SynchronousTransport transport = TransportFactory.connect(context);<br /><br />    //This is just a basic wrapper for the client transport <br />    //so it is easier to read/write messages<br />    SynchronousClient&lt;SimpleMessage&gt; client = <br />        new SynchronousClient&lt;SimpleMessage&gt;(transport);<br /><br />    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br /><br />    //Start a new thread to read from the client transport <br />    //because read is a blocking call<br />    new ReadThread(client);<br /><br />    //Now continue to write messages to the EchoServer until the user enter 'quit'<br />    while(true){<br />      System.out.println("Enter a message or type 'quit' to exit &gt;");<br />      String line = br.readLine();<br />      if(line.equalsIgnoreCase("quit")){<br />        break;<br />      }<br />      else{<br />        client.write(new SimpleMessage(line));<br />      }<br />    }<br />  }<br /><br />  private static class ReadThread extends Thread{<br />    SynchronousClient&lt;SimpleMessage&gt; client;<br />    public ReadThread(SynchronousClient&lt;SimpleMessage&gt; _client){<br />      client = _client;<br />      start();<br />    }<br /><br />    @Override<br />    public void run(){<br />      try{<br />        while(true){<br />          SimpleMessage mess = client.read(new SimpleMessage());<br />          System.out.println(mess.toString());<br />        }<br />      }<br />      catch(Exception e){<br />        e.printStackTrace();<br />      }<br />    }<br />  }<br /><br />  public static void main(String[] args) throws IOException {<br />    if(args.length == 0){<br />      usage();<br />      System.exit(1);<br />    }<br />    new EchoClient(args[0]);<br />  }<br /><br />  public static void usage(){<br />    System.out.println("EchoClient &lt;URL&gt;");<br />    System.out.println("&lt;Required parameters&gt;");<br />    System.out.println("\tURL - protocol://host:port for the server to connect to e.g. "<br />        +TransportFactory.SOCKET+"://localhost:9000");<br />  }<br />}<br /></div><div id="wwID0EOXPM" class="Body">And, the EchoServer:</div><div id="wwID0ETXPM" class="Preformatted">package com.softwareag.um.modules.examples.transport.echo;<br /><br />import com.softwareag.um.modules.transport.ServerContextBuilderFactory;<br />import com.softwareag.um.modules.transport.ServerTransportContext;<br />import com.softwareag.um.modules.transport.SynchronousServerTransport;<br />import com.softwareag.um.modules.transport.SynchronousTransport;<br />import com.softwareag.um.modules.transport.TransportFactory;<br />import com.softwareag.um.modules.examples.transport.SimpleMessage;<br />import com.softwareag.um.modules.examples.transport.SynchronousClient;<br /><br />import java.io.IOException;<br /><br />/**<br /> * This sample will only handle one client connection at a time. When a client connects,<br /> * the EchoServer will immediately respond to any messages with exactly the same message.<br /> */<br />public class EchoServer implements Runnable{<br /><br />  private volatile SynchronousClient&lt;SimpleMessage&gt; client;<br />  private final SynchronousServerTransport transport;<br />  private volatile boolean stopped = false;<br /><br />  public EchoServer(String url) throws IOException {<br />    //The factory will create the correct context based on the protocol in the url<br />    ServerTransportContext context = ServerContextBuilderFactory.getBuilder(url).build();<br /><br />    //Because we have not passed an AcceptHandler into the bind method, we are returned<br />    //a SynchronousServerTransport. This means we have to call accept on the transport<br />    //to accept new client transports.<br />    transport = TransportFactory.bind(context);<br />  }<br /><br />  public static void main(String[] args) throws IOException {<br />    if(args.length == 0){<br />      usage();<br />      System.exit(1);<br />    }<br />    EchoServer echoServer = new EchoServer(args[0]);<br />    Thread t = new Thread(echoServer);<br />    t.start();<br />    System.out.println("Press enter to quit.");<br />    System.in.read();<br />    echoServer.close();<br />  }<br /><br />  public static void usage(){<br />    System.out.println("EchoServer &lt;URL&gt;");<br />    System.out.println("&lt;Required parameters&gt;");<br />    System.out.println(<br />        "\tURL - protocol://host:port to bind the server transport to e.g. "<br />        +TransportFactory.SOCKET+"://localhost:9000");<br />  }<br /><br />  protected void close(){<br />    stopped = true;<br />    client.close();<br />    transport.close();<br />  }<br /><br />  public void run() {<br />    try{<br />      while(true){<br />        System.out.println("Waiting for client");<br /><br />        //accept() will block until a client makes a connection to our server<br />        SynchronousTransport clientTransport = transport.accept();<br />        System.out.println("Client connected.  Echo service started.");<br /><br />        //The SyncronousClient is simply a wrapper to make reading/writing easier<br />        client = new SynchronousClient&lt;SimpleMessage&gt;(clientTransport);<br />        try{<br />          while(!stopped){<br />            client.write(client.read(new SimpleMessage()));<br />          }<br />        }<br />        catch (IOException e){<br />          System.out.println("Connection closed");<br />        }<br />      }<br />    }<br />    catch(IOException e){<br />      e.printStackTrace();<br />    }<br />  }<br />}<br /></div><div id="wwID0EBYPM" class="Section_Title">Using the C++ API</div><div id="wwID0EGYPM" class="Body">Here's the C++ EchoClient:</div><div id="wwID0ELYPM" class="Preformatted">#include "EchoClient.h"<br /><br />#include "ClientTransportContextFactory.h"<br />#include "TransportFactory.h"<br />#include &lt;utility&gt;<br />#include &lt;iostream&gt;<br /><br /><br />com::softwareag::umtransport::samples::echo::EchoClient::EchoClient(std::string url)<br />{<br />  m_url = url;<br />}<br /><br />com::softwareag::umtransport::samples::echo::EchoClient::~EchoClient()<br />{<br />}<br /><br />void com::softwareag::umtransport::samples::echo::EchoClient::run(){<br />  try{<br />    //Use the factory to generate the required builder based on the protocol <br />    //in the url string<br />    auto context = ClientTransportContextFactory::build(m_url);<br /><br />    //We do not pass any handlers to the connect method <br />    //because we want a synchronous transport<br />    auto transport = TransportFactory::connect(std::move(context));<br /><br />    //This is just a basic wrapper for the client transport <br />    //so it is easier to read/write messages<br />    std::shared_ptr&lt;SynchronousTransport&gt; transportShared(std::move(transport));<br />    SynchronousClient&lt;SimpleMessage&gt; client(std::move(transportShared));<br /><br />    //Start a new thread to read from the client transport because read is a<br />    //blocking call<br />    ReadThread readThread(client);<br />    Poco::Thread th;<br />    th.start(readThread);<br /><br />    bool canRun = true;<br />    //Now continue to write messages to the EchoServer until the user enter 'quit'<br />    while (canRun){<br />      std::cout &lt;&lt; "Enter a message or type 'quit' to exit &gt;" &lt;&lt; std::endl;<br />      std::string input;<br />      std::getline(std::cin, input);<br />      if (input == "quit"){<br />        canRun = false;<br />      }<br />      else{<br />        SimpleMessage sm(input);<br />        client.write(sm);<br />      }<br />    }<br />    readThread.shutdown();<br />    client.close();<br />    th.tryJoin(10000);<br />  }<br />  catch (Poco::Exception &amp;ex){<br />    std::cout &lt;&lt; ex.displayText();<br />  }<br />}<br /><br />int com::softwareag::umtransport::samples::echo::EchoClient::main(int argc, <br />    char** argv){<br />  if (argc &lt; 2){<br />    std::cout &lt;&lt; <br />    "EchoClient &lt;URL&gt;\n&lt;Required parameters&gt;\n\tURL - " &lt;&lt;<br />    "protocol://host:port for the server to connect to e.g. tcp://localhost:9000" &lt;&lt; <br />    std::endl;<br />  }<br />  EchoClient client(argv[1]);  <br />  client.run();<br />  return 0;<br />}<br /><br />com::softwareag::umtransport::samples::echo::EchoClient::ReadThread::ReadThread(<br />SynchronousClient&lt;SimpleMessage&gt; &amp;client) : m_client(client){<br />}<br /><br />com::softwareag::umtransport::samples::echo::EchoClient::ReadThread::~ReadThread(){<br />}<br /><br />void com::softwareag::umtransport::samples::echo::EchoClient::ReadThread::shutdown(){<br />  canRun = false;<br />}<br /><br />void com::softwareag::umtransport::samples::echo::EchoClient::ReadThread::run(){  <br />  try {    <br />    while (canRun){ <br />      SimpleMessage message;<br />      m_client.read(message);<br />      std::cout &lt;&lt; "Message Content: " &lt;&lt; message &lt;&lt; std::endl;<br />    }    <br />  }<br />  catch (Poco::Exception&amp; e) {<br />    std::cout &lt;&lt; "Connection Closed " &lt;&lt; e.displayText();<br />  }  <br />}<br /></div><div id="wwID0ERYPM" class="Body">And here's the EchoServer:</div><div id="wwID0EWYPM" class="Preformatted">#include "EchoServer.h"<br />#include "ServerTransportContextFactory.h"<br />#include "TransportFactory.h"<br />#include "SynchronousClient.h"<br />#include "SimpleMessage.h"<br /><br />using namespace com::softwareag::umtransport;<br /><br /><br />com::softwareag::umtransport::samples::echo::EchoServer::EchoServer(std::string url) :  <br />stopped(false){  <br />  //The factory will create the correct context based on the protocol in the url<br />  //Because we have not passed an AcceptHandler into the bind method, we are returned<br />  //a SynchronousServerTransport. This means we have to call accept on the transport<br />  //to accept new client transports.<br />  m_transport = TransportFactory::bind(ServerTransportContextFactory::build(url));<br />}<br /><br />com::softwareag::umtransport::samples::echo::EchoServer::~EchoServer(){<br /><br />}<br /><br />int com::softwareag::umtransport::samples::echo::EchoServer::main(int argc, <br />   char** argv){<br />  if (argc &lt; 2){<br />    std::cout &lt;&lt; "EchoServer &lt;URL&gt;" &lt;&lt; std::endl &lt;&lt; "EchoServer &lt;URL&gt;" &lt;&lt; std::endl &lt;&lt; <br />    "\tURL - protocol://host:port to bind the server transport <br />     to e.g. tcp://localhost:9000" &lt;&lt; std::endl;<br />    exit(1);<br />  }<br />  EchoServer echoServer(argv[1]);<br />  Poco::Thread th;<br />  th.start(echoServer);<br /><br />  std::cout &lt;&lt; "Press any key to finish" &lt;&lt; std::endl;<br />  std::cin.ignore();<br /><br />  echoServer.close();<br />  th.tryJoin(10000);<br />  return 0;<br />}<br /><br />void com::softwareag::umtransport::samples::echo::EchoServer::close(){<br />  stopped = true;<br />  m_transport-&gt;close();<br />}<br /><br />void com::softwareag::umtransport::samples::echo::EchoServer::run(){<br />  try{<br />    while (!stopped){<br />      std::cout &lt;&lt; "Waiting for a client" &lt;&lt; std::endl;<br />      //accept() will block until a client makes a connection to our server<br />      std::shared_ptr&lt;SynchronousTransport&gt; syncTrShared(<br />           std::move(m_transport-&gt;accept()));<br />      SynchronousClient&lt;SimpleMessage&gt; client(syncTrShared);<br />      //Client connected echo servcie started<br />      try{<br />        while (!stopped){<br />          SimpleMessage msg;<br />          client.read(msg);<br />          client.write(msg);<br />        }<br />      }<br />      catch (Poco::Exception &amp; ex){<br />        std::cout &lt;&lt; "Connection Closed" &lt;&lt; std::endl;<br />      }<br />    }<br />  }<br />  catch (Poco::Exception &amp;ex){<br />    std::cout &lt;&lt; ex.displayText() &lt;&lt; std::endl;<br />  }<br />}</div><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><!-- SQ insert Footer --><br /><hr style="border:1px solid; border-color: #1776BF; " /><!-- FRWE: Why is the font family information hard-coded?? --><div style="font-family: 'Roboto', Sans-Serif; font-size: 10px; margin-top: 6px; margin-bottom: 6px; text-align: center;"><a href="http://www.softwareag.com/licenses">Copyright © 2013-2022&nbsp;Software AG, Darmstadt, Germany and/or Software AG USA, Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors</a></div><!-- SQ insert Date 
	 <div style="text-align: center; font-weight: bold;" wwpage:content="pub-date">January 1, 2015</div> --><!-- old Footer 2016
	  <div class="footer">Copyright &#169; <span wwpage:content="sag:product-copyrfirst"></span>, <span wwpage:content="sag:organization-copyrholder"></span>, <a href="http://sag.com/" wwpage:attribute-href="sag:organization-url" wwpage:content="sag:organization-url">http://sag.com/</a>
   --><!-- SQ Variablen --><!-- Copyright Test --><!--	  <div style="text-decoration: underline">Copyright Import Test:</div>
	  <wwpage:Import wwpage:content-from-file="Copyright/copyright_en.asp" />
	  <br></br>--><!--
	  <!-\- SQ Variables - Information from xresources -\->
	  <div style="text-decoration: underline">From xresources:</div>
	  <div>sag:organization-id == <span wwpage:content="sag:organization-id"></span></div>
	  <div>sag:organization-name == <span wwpage:content="sag:organization-name"></span></div>
	  <div>sag:organization-copyrholder == <span wwpage:content="sag:organization-copyrholder"></span></div>
	  <div>sag:organization-url == <span wwpage:content="sag:organization-url"></span></div>
	  
	  <div>sag:family-id == <span wwpage:content="sag:family-id"></span></div>
	  <div>sag:family-name == <span wwpage:content="sag:family-name"></span></div>
	  <div>sag:family-organization == <span wwpage:content="sag:family-organization"></span></div>
	  
	  <div>sag:product-id == <span wwpage:content="sag:product-id"></span></div>
	  <div>sag:product-name == <span wwpage:content="sag:product-name"></span></div>
	  <div>sag:product-copyrfirst == <span wwpage:content="sag:product-copyrfirst"></span></div>
	  <div>sag:product-family == <span wwpage:content="sag:product-family"></span></div>
	  
	  <!-\- SQ Variables - Values from DITA-Map and Keymap-\->
	  <br></br>
	  <div style="text-decoration: underline">From DITA/Book-Map:</div>
	  <div>ProdInfo Prodname == <span wwpage:replace="wwvars:ProdInfoProdName"></span></div>
	  <div>ProdInfo Mod First == <span wwpage:replace="wwvars:ProdInfoModFirst"></span></div>
	  <div>ProdInfo Mod Last == <span wwpage:replace="wwvars:ProdInfoModLast"></span></div>
	  <div>ProdInfo Rel First == <span wwpage:replace="wwvars:ProdInfoRelFirst"></span></div>
	  <div>ProdInfo Rel Last == <span wwpage:replace="wwvars:ProdInfoRelLast"></span></div>
	  <div>ProdInfo Vers First == <span wwpage:replace="wwvars:ProdInfoVersFirst"></span></div>
	  <div>ProdInfo Vers Last == <span wwpage:replace="wwvars:ProdInfoVersLast"></span></div>
	  <div>ProdInfo vrm vers.rel.mod == <span wwpage:replace="wwvars:ProdInfoVersFirst"></span>.<span wwpage:replace="wwvars:ProdInfoRelLast"></span>.<span wwpage:replace="wwvars:ProdInfoModLast"></span></div>
	  <div>BookID PartNo == <span wwpage:replace="wwvars:BookPartNo"></span></div>
	  <div>othermeta release-version == <span wwpage:replace="wwvars:ReleaseVersion"></span></div>
	  <div>othermeta release-date == <span wwpage:replace="wwvars:ReleaseDate"></span></div>
	  <div>othermeta release-edition == <span wwpage:replace="wwvars:ReleaseEdition"></span></div>
	  <div>othermeta product == <span wwpage:replace="wwvars:Product"></span></div>
	  <br></br>
	  <div style="text-decoration: underline">From x_runtime/keymap.ditamap:</div>
	  <div>sag:product-shortname == <span wwpage:replace="wwvars:sag:product-shortname"></span></div>
	  <div>sag:product-longname == <span wwpage:replace="wwvars:sag:product-longname"></span></div>
	  <div>versionAdd == <span wwpage:replace="wwvars:versionAdd"></span></div>
	  <div>yearFYLY == <span wwpage:replace="wwvars:yearFYLY"></span></div>
	  <div>fingerprint == <span wwpage:replace="wwvars:fingerprint"></span></div>
	  <div>sag:CopyrightDeclaration == <span wwpage:replace="wwvars:sag:CopyrightDeclaration"></span></div>
	  <div>pdfReleaseDate == <span wwpage:replace="wwvars:pdfReleaseDate"></span></div>
	  <div>documentID == <span wwpage:replace="wwvars:documentID"></span></div>
	  <br></br>
	  <div style="text-decoration: underline">Reserve:</div>
	  <div>organization == <span wwpage:content="organization"></span></div>
	  <div>product-name == <span wwpage:content="product-name"></span></div>
	  <div>copyright-first == <span wwpage:content="copyright-first"></span></div>
	  <div>copyright-last == <span wwpage:content="copyright-last"></span></div>
	  <div>copyright-first-b == <span wwpage:content="wwvars:copyright-first-b"></span></div>
	  <div>copyright-last-b == <span wwpage:content="copyright-last-b"></span></div>
	  <div>doc-id-one == <span wwpage:content="doc-id-one"></span></div>
	  <div>doc-id-two == <span wwpage:content="doc-id-two"></span></div>  
	  <div>Published == <span wwpage:content="pub-date"></span></div>
	  --></footer></body></html>